== Application Assembly and Deployment
:imagesdir: ../images

This chapter specifies Jakarta™ Enterprise Edition (Jakarta EE) requirements for assembling, packaging, and
deploying a Jakarta EE application. The main goal of these requirements is
to provide scalable and modular application assembly, and portable
deployment of Jakarta EE applications into any Jakarta EE product.

Jakarta EE applications are composed of one or
more Jakarta EE components and an optional Jakarta EE application deployment
descriptor. The deployment descriptor, if present, lists the
application’s components as _modules_. If the deployment descriptor is
not present, the application’s modules are discovered using default
naming rules. A Jakarta EE module represents the basic unit of composition
of a Jakarta EE application. Jakarta EE modules consist of one or more Jakarta EE
components and an optional module level deployment descriptor. The
flexibility and extensibility of the Jakarta EE component model facilitates
the packaging and deployment of Jakarta EE components as individual
components, component libraries, or Jakarta EE applications.

A full Jakarta EE product must support all the
facilities described in this chapter. A Jakarta EE profile may support only
a subset of the Jakarta EE module types. Any requirements related to a
module type not supported by a product based on a particular Jakarta EE
profile should be understood to not apply to such a product.


<<a2899, Jakarta EE Deployment>>
shows the composition model for Jakarta EE deployment units and includes
the optional use of alternate deployment descriptors by the application
package to preserve any digital signatures of the original Jakarta EE
modules. An alternate deployment descriptor may also be provided
external to the application package as described in
<<a3125, Assembling a Jakarta EE Application>>.

[[a2899]]
.Jakarta EE Deployment
image::deployment-schema.svg[]

=== Application Development Life Cycle

The development life cycle of a Jakarta EE
application begins with the creation of discrete Jakarta EE components.
These components may then be packaged with a module level deployment
descriptor to create a Jakarta EE module. Jakarta EE modules can be deployed
as stand-alone units or can be assembled with a Jakarta EE application
deployment descriptor and deployed as a Jakarta EE application.


<<a2903, Jakarta EE Application Life Cycle>> 
shows the life cycle of a Jakarta EE application.

[[a2903]]
.Jakarta EE Application Life Cycle
image::deploy.svg[]

[[a2904]]
==== Component Creation

The Jakarta Enterprise Beans, Jakarta Servlet, application client, and
Jakarta Connector specifications include the XML Schema definition of the
associated module level deployment descriptors and component packaging
architecture required to produce Jakarta EE modules. (The application
client specification is found in
<<a3294, Application Clients chapter>> of this
document.)

A Jakarta EE module is a collection of one or more
Jakarta EE components (web, Jakarta Enterprise Beans, application client, or Jakarta Connector) with an
optional module deployment descriptor of that type. Any number of
components of the same container type can be packaged together with a
single Jakarta EE deployment descriptor appropriate to that container type
to produce a Jakarta EE module. Components of different container types may
not be mixed in a single Jakarta EE module, except for the packaging of Jakarta Enterprise Beans
components within a web module.

* A Jakarta EE module represents the basic unit of
composition of a Jakarta EE application. In some cases a single Jakarta EE
module (not necessarily packaged into a Jakarta EE application package)
will contain an entire application. In other cases an application will
be composed of multiple Jakarta EE modules.
* The deployment descriptor for a Jakarta EE
module contains declarative data required to deploy the components in
the module. The deployment descriptor for a Jakarta EE module also contains
assembly instructions that describe how the components are composed into
an application.
* Starting with version 5 of the Java EE, a web application module, an enterprise bean module, or an
application client module need not contain a deployment descriptor.
Instead, the deployment information may be specified by annotations
present in the class files of the module.
* Starting with version 5 of the Java EE, a Jakarta EE enterprise application archive need not contain a
deployment descriptor. Instead, the deployment information may be
determined using default naming rules for embedded modules.
* An individual Jakarta EE module can be
deployed as a stand-alone Jakarta EE module without an application level
deployment descriptor and represents a valid Jakarta EE application.
* Jakarta EE modules may express dependencies on
libraries as described below in
<<a2945, Library Support>>.

All Jakarta EE modules have a name. The name can
be explicitly set in the deployment descriptor for the module. If not
set, the name of the module is the pathname of the module in the ear
file with any filename extension (.jar, .war, .rar) removed, but with
any directory names included. The name of a module must be unique within
an application. If and only if the name is not unique (e.g., because two
names are identical after removing different filename extensions) the
deployment tool may choose new unique names for any of the conflicting
modules; module names that do not conflict must not be changed. The
algorithm for choosing unique names in such a case is product specific.
Applications that depend on the names of their modules must ensure that
their module names are unique.

For example, an application with this structure:

----
myapp.ear
 inventory.jar
 ui.war
----


has a default application name of "myapp",
and defines two modules with default names "inventory" and "ui".

An application with this structure:

----
bigapp.ear
 ejbs
   inventory.jar
   accounts.jar
 ui
   store.war
   admin.war
----


has a default application name of "bigapp",
and defines four modules with default names "ejbs/inventory",
"ejbs/accounts", "ui/store", and "ui/admin".

==== Application Assembly

A Jakarta EE application may consist of one or
more Jakarta EE modules and one Jakarta EE application deployment descriptor.
A Jakarta EE application is packaged using the Jakarta Archive (JAR) file
format into a file with a _.ear_ (Enterprise ARchive) filename
extension. A minimal Jakarta EE application package will only contain Jakarta
EE modules and, optionally, the application deployment descriptor. A
Jakarta EE application package may also include libraries referenced by
Jakarta EE modules (using the _Class-Path_ mechanism described below in
<<a2945, Library Support>>),
help files, and documentation to aid the deployer.

The deployment of a portable Jakarta EE
application should not depend on any entities that may be contained in
the package other than those defined by this specification. Deployment
of a portable Jakarta EE application must be possible using only the
application deployment descriptor, if any, and the Jakarta EE modules (and
their dependent libraries) and descriptors listed in it.

The Jakarta EE application deployment descriptor
represents the top level view of a Jakarta EE application’s contents. The
Jakarta EE application deployment descriptor is specified by an XML schema
or document type definition (see
<<a3203, Jakarta EE Application XML Schema>>).

In certain cases, a Jakarta EE application will
need customization before it can be deployed into the enterprise. New
Jakarta EE modules may be added to the application. Existing modules may be
removed from the application. Some Jakarta EE modules may need custom
content created, changed, or replaced. For example, an application
consumer may need to use an HTML editor to add company graphics to a
template login page that was provided with a Jakarta EE web application.

All Jakarta EE applications have a name. The
name can be explicitly set in the application deployment descriptor. If
not set, the name of the application is the base name of the ear file
with any _.ear_ extension removed and with any directory names removed.
The name of an application must be unique in an application server
instance. If an attempt is made to deploy an application with a name
that conflicts with an already deployed application, the deployment tool
may choose a new unique name for the application. The deployment tool
may also allow a different name to be specified at deployment time. A
deployment tool may use product-specific means to decide whether a
deployment operation is a deployment of a new application, in which case
the name must be unique, or a redeployment of an existing application,
in which case the name may match the existing application.

Similarly, when a stand-alone module is
deployed, the module name is used as the application name, and obeys the
same rules as described above for application names. The module name can
be explicitly set in the module deployment descriptor. If not set, the
name of the module is the base name of the module file with any
extension ( _.war_ , _.jar_ , _.rar_ ) removed and with any directory
names removed.

==== Deployment

During the deployment phase of an
application’s life cycle, the application is installed on the Jakarta EE
platform and then is configured and integrated into the existing
infrastructure. Each Jakarta EE module listed in the application deployment
descriptor (or discovered using the default rules described below) must
be deployed according to the requirements of the specification for the
respective Jakarta EE module type. Each module listed must be installed in
the appropriate container type and the environment properties of each
module must be set appropriately in the target container to reflect the
values declared by the deployment descriptor element for each component.

Every resource reference should be bound to a
resource of the required type.

Some resources have default mapping rules
specified; see sections <<a2009, Default Data Source>>, <<a2025, Default JMS Connection Factory>>, and
<<a2042, Default Concurrency Utilities Objects>>. By default, a product must map otherwise unmapped
resources using these default rules. A product may include an option to
disable or override these default mapping rules.

Once a resource reference is bound to a
resource in the target operational environment, and deployment succeeds,
that binding is not expected to change. A product may provide
administrative operations that change the resource bindings that are
used by applications. A product may notify applications of changes to
their resource bindings using JNDI events, but this is not required.

If deployment succeeds, in addition to
binding resource references as specified above, every resource
definition (see section <<a1652, Resource Definition and Configuration>>) specified by the application or
specified or overridden by the Deployer must be present in the target
operational environment.

[[a2945]]
=== Library Support

The Jakarta EE provides several
mechanisms for applications to use optional packages and shared
libraries (hereafter referred to as _libraries_ ). Libraries may be
bundled with an application or may be installed separately for use by
any application.

Jakarta EE products are required to support the
use of bundled and installed libraries as specified in the _Extension
Mechanism Architecture_ and _Optional Package Versioning_ specifications
(available at
_https://docs.oracle.com/javase/8/docs/technotes/guides/extensions/_ )
and the JAR File Specification (available at
_https://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html_ ).
Using this mechanism a Jakarta EE JAR file can reference utility classes or
other shared classes or resources packaged in a separate _.jar_ file or
directory that is included in the same Jakarta EE application package, or
that has been previously installed in the Jakarta EE containers.

[[a2948]]
==== Bundled Libraries

Libraries bundled with an application may be
referenced in the following ways:

. A JAR format file (such as a _.jar_ file,
_.war_ file, or _.rar_ file) may reference a _.jar_ file or directory by
naming the referenced _.jar_ file or directory in a _Class-Path_ header
in the referencing JAR file’s Manifest file. The referenced _.jar_ file
or directory is named using a URL relative to the URL of the referencing
JAR file. The Manifest file is named _META-INF/MANIFEST.MF_ in the JAR
file. The _Class-Path_ entry in the Manifest file is of the form

Class-Path:
list-of-jar-files-or-directories-separated-by-spaces

(See the JAR File Specification for important
details and limitations of the syntax of _Class-Path_ headers.) The Jakarta
EE deployment tools must process all such referenced files and
directories when processing a Jakarta EE module. Any deployment descriptors
in referenced _.jar_ files must be ignored when processing the
referencing _.jar_ file. The deployment tool must install the _.jar_
files and directories in a way that preserves the relative references
between the files. Typically this is done by installing the _.jar_ files
into a directory hierarchy that matches the original application
directory hierarchy. All referenced _.jar_ files or directories must
appear in the logical class path of the referencing JAR files at
runtime.

Only JAR format files or directories
containing class files or resources to be loaded directly by a standard
class loader should be the target of a _Class-Path_ reference; such
files are always named with a _.jar_ extension. Top level JAR files that
are processed by a deployment tool should not contain _Class-Path_
entries; such entries would, by definition, reference other files
external to the deployment unit. A deployment tool is not required to
process such external references.

. A _.ear_ file may contain a directory that
contains libraries packaged in JAR files. The _library-directory_
element of the _.ear_ file’s deployment descriptor contains the name of
this directory. If a _library-directory_ element isn’t specified, or if
the _.ear_ file does not contain a deployment descriptor, the directory
named _lib_ is used. An empty _library-directory_ element may be used to
specify that there is no library directory.

All files in this directory (but not
subdirectories) with a _.jar_ extension must be made available to all
components packaged in the EAR file, including application clients.
These libraries may reference other libraries, either bundled with the
application or installed separately, using any of the techniques
described herein.

. A web application may include libraries in
the _WEB-INF/lib_ directory. See the Jakarta Servlet specification for details.
These libraries may reference other libraries, either bundled with the
application or installed separately, using any of the techniques
described herein.

==== Installed Libraries

Libraries that have been installed separately
may be referenced in the following way:

. JAR format files of all types may contain
an _Extension-List_ attribute in their Manifest file, indicating a
dependency on an installed library. The JAR File Specification defines
the semantics of such attributes; this specification
requires support for such attributes for all component types and
corresponding JAR format files. The deployment tool is required to check
such dependency information and reject the deployment of any component
for which the dependency can not be met. Portable applications should
not assume that any installed libraries will be available to a component
unless the component’s JAR format file, or one of the containing JAR
format files, expresses a dependency on the library using the
_Extension-List_ and related attributes.

The referenced libraries must be made
available to all components contained within the referencing file,
including any components contained within other JAR format files within
the referencing file. For example, if a _.ear_ file references an
installed library, the library must be made available to all components
in all _.war_ files, Jakarta Enterprise Beans _.jar_ files, application _.jar_ files, and
resource adapter _.rar_ files within the _.ear_ file.

A Jakarta EE product is not required to support
downloading of libraries (using the _<extension>-Implementation-URL_
header) at deployment time or runtime. A Jakarta EE product is also not
required to support more than a single version of an installed library
at once. A Jakarta EE product is not required to limit access to installed
libraries to only those for which the application has expressed a
dependency; the application may be given access to more installed
libraries than it has requested. In all of these cases, such support is
highly recommended and may be required in a future version of this
specification. In particular, we recommend that a Jakarta EE product
support multiple versions of an installed library, and by default only
allow applications to access the installed libraries for which they have
expressed a dependency.

==== Library Conflicts

If an application includes a bundled version
of a library, and the same library exists as an installed library, the
instance of the library bundled with the application should be used in
preference to any installed version of the library. This allows an
application to bundle exactly the version of a library it requires
without being influenced by any installed libraries. Note that if the
library is also a required component of the Jakarta EE version on
which the application is being deployed, this version may (and
typically will) take precedence.

==== Library Resources

In addition to allowing access to referenced
classes, as described above, any resources contained in the referenced
JAR files must also be accessible using the _Class_ and _ClassLoader_
_getResource_ methods, as allowed by the security permissions of the
application. An application will typically have the security permissions
required to access resources in any of the JAR files packaged with the
application.

[[a2966]]
==== Dynamic Class Loading

Libraries that dynamically load classes must
consider the class loading environment of a Jakarta EE application.
Libraries will often be loaded by a class loader that is a parent class
loader of the class loader that is used to load application classes and
thus will not have direct visibility to classes of the application
modules. A library that only needs to dynamically load classes provided
by the library itself can safely use the _Class_ method _forName_ .
However, libraries that need to dynamically load classes that have been
provided as a part of the application need to use the context class
loader to load the classes. Note that the context class loader may be
different in each module of an application. Access to the context class
loader requires _RuntimePermission_ (“ _getClassLoader”)_ , which is not
normally granted to applications, but should be granted to libraries
that need to dynamically load classes. Libraries can use a method such
as the following to assert their privilege when accessing the context
class loader. This technique will work in both Java SE and Jakarta EE.


[source,java]
----
public ClassLoader getContextClassLoader() {
  return AccessController.doPrivileged(
    new PrivilegedAction<ClassLoader>() {
      public ClassLoader run() {
        ClassLoader cl = null;
        try {
          cl = Thread.currentThread().
                        getContextClassLoader();
        } catch (SecurityException ex) { }
        return cl;
      }
    });
}
----

Libraries should then use the following technique to load classes.

[source,java]
----
ClassLoader cl = getContextClassLoader();
if (cl != null) {
  try {
    clazz = Class.forName(name, false, cl);
  } catch (ClassNotFoundException ex) {
    clazz = Class.forName(name);
  }
 } else
  clazz = Class.forName(name);
----

==== Examples

The following example illustrates a simple
use of the bundled library mechanism to reference a library of utility
classes that are shared between enterprise beans in two separate ejb-jar
files.

----
app1.ear:
 META-INF/application.xml
 ejb1.jar      Class-Path: util.jar
 ejb2.jar      Class-Path: util.jar
 util.jar
----


The next example illustrates a more complex
use of the _Class-Path_ mechanism. In this example the Developer has
chosen to package the enterprise bean client view classes in a separate
JAR file and reference that JAR file from the other JAR files that need
those classes. Those classes are needed both by _ejb2.jar_ , packaged in
the same application as _ejb1.jar_ , and by _ejb3.jar_ and
_jakartaservlet1.jar_ , packaged in a different application. Those classes are
also needed by _ejb1.jar_ itself because they define the remote
interface of the enterprise beans in _ejb1.jar_ , and the developer has
chosen the by reference model of making these classes available, as
described in the Jakarta Enterprise Beans spec. The deployment descriptor for _ejb1.jar_
names the client view JAR file in the _ejb-client-jar_ element.

The _Class-Path_ mechanism must be used by
components in _app3.ear_ to reference the client view JAR file that
corresponds to the enterprise beans packaged in _ejb1.jar_ of _app2.ear_
. These enterprise beans are referenced by enterprise beans in
_ejb3.jar_ and by the Jakarta Servlets packaged in _webapp.war_ .

[subs=+quotes]
----
app2.ear:
  META-INF/application.xml
  ejb1.jar      Class-Path: ejb1_client.jar
    _deployment descriptor contains_:
        <ejb-client-jar>ejb1_client.jar</ejb-client-jar>
  ejb1_client.jar
  ejb2.jar      Class-Path: ejb1_client.jar

app3.ear:
  META-INF/application.xml
  ejb1_client.jar
  ejb3.jar      Class-Path: ejb1_client.jar
  webapp.war    Class-Path: ejb1_client.jar
     WEB-INF/web.xml
     WEB-INF/lib/jakartaservlet1.jar
----

The following example illustrates a simple
use of the installed library mechanism to reference a library of utility
classes that is installed separately.

----
app1.ear:
  META-INF/application.xml
  ejb1.jar :
    META-INF/MANIFEST.MF:
      Extension-List: util
      util-Extension-Name: com/example/util
      util-Specification-Version: 1.4
    META-INF/ejb-jar.xml

util.jar:
  META-INF/MANIFEST.MF:
  Extension-Name: com/example/util
  Specification-Title: example.com’s util package
  Specification-Version: 1.4
  Specification-Vendor: example.com
  Implementation-Version: build96
----

[[a3040]]
=== Class Loading Requirements

The Jakarta EE specification
purposely does not define the exact types and arrangements of class
loaders that must be used by a Jakarta EE product. Instead, the
specification defines requirements in terms of what classes must or must
not be visible to components. A Jakarta EE product is free to use whatever
class loaders it chooses to meet these requirements. Portable
applications must not depend on the types of class loaders used or the
hierarchical arrangement of class loaders, if any. Portable applications
must not depend on the order in which classes and resources are loaded.
Applications should use the techniques described in
<<a2966, Dynamic Class Loading>>
if they need to load classes dynamically.

In addition to the required classes specified
below, a Jakarta EE product must provide a way to allow an application to
access a class library installed in the application server, even if it
has not expressed a dependency on that library. This supports the use of
old applications and extension libraries that do not use the defined
extension dependency mechanism.

The following sections describe the
requirements for each container type. In all cases, access to classes is
governed by the rules of the Java language and the Java virtual machine.
In all cases, access to classes and resources is governed by the rules
of the Java security model.

Note that while libraries must be accessible
to application classes as described below, it may be necessary to use
the techniques described in
<<a2966, Dynamic Class Loading>>
if libraries need to access classes packaged in the application modules.

[[a3046]]
==== Web Container Class Loading Requirements

Components in the web container must have
access to the following classes
and resources. Note that as of Java EE 6, Java Enterprise Beans
components may be packaged in a web component module. Such Java Enterprise Beans
components have the same access as other components in the web
container. See the Jakarta Enterprise Beans specification for further detail.

* The content of the _WEB-INF/classes_
directory of the containing war file.
* The content of all jar files in the
_WEB-INF/lib_ directory of the containing war file, but not any
subdirectories.
* The transitive closure of any libraries
referenced by the above jar files (as specified in
<<a2945, Library Support>>).
* The transitive closure of any libraries
referenced by the war file itself (as specified in
<<a2945, Library Support>>).
* The transitive closure of any libraries
specified by or referenced by the containing ear file (as specified in
<<a2945, Library Support>>).
* The contents of all jar files included in
any resource adapter archives (rar files) included in the same ear file.
* The contents of all jar files included in
each resource adapter archive (rar file) deployed separately to the
application server, if that resource adapter is used to satisfy any
resource references in the module.
* The contents of all jar files included in
each resource adapter archive (rar file) deployed separately to the
application server, if any jar file in that rar file is used to satisfy
any reference from the module using the Extension Mechanism Architecture
(as specified in <<a2945, Library Support>>).
* The transitive closure of any libraries
referenced by the jar files in the rar files above (as specified in
<<a2945, Library Support>>).
* The transitive closure of any libraries
referenced by the rar files themselves (as specified in
<<a2945, Library Support>>).
* The Jakarta EE API classes specified in
<<a2159, Jakarta EE Technologies>> for the web container.
* All required <<a3537, Java SE API classes>>.



Components in the web container may have
access to the following classes and resources. Portable applications
must not depend on having or not having access to these classes or
resources.

* The classes and resources accessible to any
other web modules included in the same ear file, as described above.
* The content of any Jakarta Enterprise Beans jar files included
in the same ear file.
* The content of any client jar files
specified by the above Jakarta Enterprise Beans jar files.
* The transitive closure of any libraries
referenced by the above Jakarta Enterprise Beans jar files and client jar files (as specified
in <<a2945, Library Support>>).
* The contents of any jar files included in
any resource adapter archives (rar files) deployed separately to the
application server.
* The transitive closure of any libraries
referenced by the jar files in the rar files above (as specified in
<<a2945, Library Support>>).
* The transitive closure of any libraries
referenced by the rar files above themselves (as specified in
<<a2945, Library Support>>).
* The Jakarta EE API classes specified in
<<a2159, Jakarta EE Technologies>> for the containers other than the web container.
* Any installed libraries available in the
application server.
* Other classes or resources contained in the
application package, and specified by an explicit use of an extension
not defined by this specification.
* Other classes and resources that are part
of the implementation of the application server.



Components in the web container must not have
access to the following classes and resources, unless such classes or
resources are covered by one of the rules above.

* Other classes or resources in the
application package. For example, the application should not have access
to the classes in application client jar files.

==== Jakarta Enterprise Beans Container Class Loading Requirements

Components in the Jakarta Enterprise Beans container must have
access to the following classes and resources.

* The content of the Jakarta Enterprise Beans jar file.
* The transitive closure of any libraries
referenced by the Jakarta Enterprise Beans jar file (as specified in
<<a2945, Library Support>>).
* The transitive closure of any libraries
specified by or referenced by the containing ear file (as specified in
<<a2945, Library Support>>).
* The contents of all jar files included in
any resource adapter archives (rar files) included in the same ear file.
* The contents of all jar files included in
each resource adapter archive (rar file) deployed separately to the
application server, if that resource adapter is used to satisfy any
resource references in the module.
* The contents of all jar files included in
each resource adapter archive (rar file) deployed separately to the
application server, if any jar file in that rar file is used to satisfy
any reference from the module using the Extension Mechanism Architecture
(as specified in <<a2945, Library Support>>).
* The transitive closure of any libraries
referenced by the jar files in the rar files above (as specified in
<<a2945, Library Support>>.
* The transitive closure of any libraries
referenced by the rar files themselves (as specified in
<<a2945, Library Support>>).
* The Jakarta EE API classes specified in
<<a2159, Jakarta EE Technologies>> for the Jakarta Enterprise Beans container.
* All required <<a3537, Java SE API classes>>.



Components in the Jakarta Enterprise Beans container may have
access to the following classes and resources. Portable applications
must not depend on having or not having access to these classes or
resources.

* The classes and resources accessible to any
web modules included in the same ear file, as described in
<<a3046, Web Container Class Loading Requirements>> above.
* The content of any Jakarta Enterprise Beans jar files included
in the same ear file.
* The content of any client jar files
specified by the above Jakarta Enterprise Beans jar files.
* The transitive closure of any libraries
referenced by the above Jakarta Enterprise Beans jar files and client jar files (as specified
in <<a2945, Library Support>>).
* The contents of any jar files included in
any resource adapter archives (rar files) deployed separately to the
application server.
* The transitive closure of any libraries
referenced by the jar files in the rar files above (as specified in
<<a2945, Library Support>>).
* The transitive closure of any libraries
referenced by the rar files above themselves (as specified in
<<a2945, Library Support>>).
* The Jakarta EE API classes specified in
<<a2159, Jakarta EE Technologies>> for the containers other than the Jakarta Enterprise Beans container.
* Any installed libraries available in the
application server.
* Other classes or resources contained in the
application package, and specified by an explicit use of an extension
not defined by this specification.
* Other classes and resources that are part
of the implementation of the application server.

Components in the Jakarta Enterprise Beans container must not have
access to the following classes and resources, unless such classes or
resources are covered by one of the rules above.

* Other classes or resources in the
application package. For example, the application should not have access
to the classes in application client jar files.

==== Application Client Container Class Loading Requirements

Components in the application client
container must have access to the following classes and resources.

* The content of the application client jar
file.
* The transitive closure of any libraries
referenced by the above jar file (as specified in
<<a2945, Library Support>>).
* The transitive closure of any libraries
specified by or referenced by the containing ear file (as specified in
<<a2945, Library Support>>).
* The Jakarta EE API classes specified in
<<a2159, Jakarta EE Technologies>> for the application client container.
* All required <<a3537, Java SE API classes>>.



Components in the application client
container may have access to the following classes and resources.
Portable applications must not depend on having or not having access to
these classes or resources.

* The Jakarta EE API classes specified in
<<a2159, Jakarta EE Technologies>> for the containers other than the application client
container.
* Any installed libraries available in the
application server.
* Other classes or resources contained in the
application package, and specified by an explicit use of an extension
not defined by this specification.
* Other classes and resources that are part
of the implementation of the application server.



Components in the application client
container must not have access to the following classes and resources,
unless such classes or resources are covered by one of the rules above.

* Other classes or resources in the
application package. For example, the application client should not have
access to the classes in other application client jar files in the same
ear file, nor should it have access to the classes in web applications
or Jakarta Enterprise Beans jar files in the same ear file.

=== Application Assembly

This section specifies the sequence of steps
that are typically followed when composing a Jakarta EE application.

[[a3125]]
==== Assembling a Jakarta EE Application

. Select the Jakarta EE modules that will be used
by the application.
. Create an application directory structure.

The directory structure of an application is
arbitrary, but by following some simple conventions a deployment
descriptor may not be needed. The structure should be designed around
the requirements of the contained components.

. Reconcile Jakarta EE module deployment
descriptors.

The deployment descriptors for the Jakarta EE
modules must be edited to link internally satisfied dependencies and
eliminate any redundant security role names. An optional element
_alt-dd_ (described in <<a3203, Jakarta EE Application XML Schema>>) may be used when it is desirable to
preserve the original deployment descriptor. The element _alt-dd_
specifies an alternate deployment descriptor to use at deployment time.
The edited copy of the deployment descriptor file may be saved in the
application directory tree in a location determined by the Application
Assembler. If the _alt-dd_ element is not present, the Deployer must
read the deployment descriptor directly from the module package.

. Choose unique names for the modules contained
in the application. If two modules specify conflicting names in their
deployment descriptors, create an alternate deployment descriptor for at
least one of the modules and change its name. If two modules in the same
directory of the ear file have the same base name (e.g., _foo.jar_ and
_foo.war_ ), rename one of the modules or create an alternate deployment
descriptor to specify a unique name for one of the modules.
. Link the internally satisfied dependencies
of all components in every module contained in the application. For each
component dependency, there must only be one corresponding component
that fulfills that dependency in the scope of the application.
. For each _ejb-link_ , there must be only one
matching _ejb-name_ in the scope of the entire application (see
<<a936, Enterprise JavaBeans™ (EJB) References>>).
. Dependencies that are not linked to internal
components must be handled by the Deployer as external dependencies that
must be met by resources previously installed on the platform. External
dependencies must be linked to the resources on the platform during
deployment.
. Synchronize security role-names across the
application. Rename unique role-names with redundant meaning to a common
name. Rename role-names with common names but different meanings to
unique names. Descriptions of role-names that are used by many
components of the application can be included in the application-level
deployment descriptor.
. Assign a context root for each web module
included in the Jakarta EE application. The context root is a relative name
in the web namespace for the application. Each web module must be given
a distinct and non-overlapping name for its context root. The web
modules will be assigned a complete name in the namespace of the web
server at deployment time. If there is only one web module in the Jakarta
EE application, the context root may be the empty string. If no
deployment descriptor is included in the application package, it will
use the default-context-path in the web module. Otherwise, it will use
the module name as the context root of the web module. See the Jakarta Servlet
specification for detailed requirements of context root naming.
. Make sure that each component in the
application properly describes any dependencies it may have on other
components in the application. A Jakarta EE application should not assume
that all components in the application will be available on the class
path of the application at run time. Each component might be loaded into
a separate class loader with a separate namespace. If the classes in a
JAR file depend on classes in another JAR file, the first JAR file
should reference the second JAR file using the _Class-Path_ mechanism. A
notable exception to this rule is JAR files located in the _WEB-INF/lib_
directory of a web application. All such JAR files are included in the
class path of the web application at runtime; explicit references to
them using the _Class-Path_ mechanism are not needed. Another exception
to this rule is JAR files located in the library directory (usually
named _lib_ ) in the application package. Note that the presence of
component-declaring annotations in shared artifacts, such as libraries
in the library directory and libraries referenced by more than one
module through _Class-Path_ references, can have unintended and
undesirable consequences and is not recommended.
. There must be only one version of each class
in an application. If one component depends on one version of a library,
and another component depends on another version, it may not be possible
to deploy an application containing both components. With the exception
of application clients, a Jakarta EE application should not assume that
each component is loaded in a separate class loader and has a separate
namespace. All components in a single application may be loaded in a
single class loader and share a single namespace. Note, however, that it
must be possible to deploy an application such that all components of
the application are in a namespace (or namespaces) separate from that of
other applications. Typically, this will be the normal method of
deployment. By default, application clients are each deployed into their
own Java virtual machine instance, and thus each application client has
its own class namespace, and the classes from application clients are
not visible in the class namespace of other components.
. (Optional) Create an XML deployment
descriptor for the application.

The deployment descriptor must be named
_application.xml_ and must reside in the top level of the _META-INF_
directory of the application _.ear_ file. The deployment descriptor must
be a valid XML document according to the XML schema for a Jakarta EE
application XML document. (Alternatively, the deployment descriptor may
meet the requirements of previous versions of Jakarta EE.)

Many applications that follow the conventions
described below will not need a deployment descriptor for the
application. The deployment tool will determine the components of the
application using some simple rules.

. Package the application.
. Place the Jakarta EE modules and the deployment
descriptor in the appropriate directories.
. Package the application directory hierarchy
in a file using the JAR file format. The file should be named with a
_.ear_ filename extension.
. (Optional) Create an alternate deployment
descriptor (“alt-dd”) for the application, external to the packaged
application.

==== Adding and Removing Modules

After the application is created, Jakarta EE
modules may be added or removed before deployment. When adding or
removing a module the following steps must be performed:

. Decide on a location in the application
package for the new module. Optionally create new directories in the
application package hierarchy to contain any Jakarta EE modules that are
being added to the application.
. Ensure that the name of the new module does
not conflict with any of the existing modules, either by choosing an
appropriate default filename for the module or by explicitly specifying
the module name in the module’s deployment descriptor or in an alternate
deployment descriptor.
. Copy the new Jakarta EE modules to the desired
location in the application package. The packaged modules are inserted
directly in the desired location; the modules are not unpackaged.
. Edit the deployment descriptors for the Jakarta
EE modules to link the dependencies which are internally satisfied by
the Jakarta EE modules included in the application.
. Edit the Jakarta EE application deployment
descriptor (if included) to meet the content requirements of the Jakarta EE
 and the validity requirements of the Jakarta EE application XML
DTD or schema.

[[a3153]]
=== Deployment

The Jakarta EE supports three types of
deployment units:

* Stand-alone Jakarta EE modules.
* Jakarta EE applications, consisting of one or
more Jakarta EE modules.
* Class libraries packaged as _.jar_ files
according to the _Extension Mechanism Architecture_ . These class
libraries then become installed libraries.

Any Jakarta EE product must be able to accept a
Jakarta EE application delivered as a _.ear_ file or a stand-alone Jakarta EE
module delivered as a _.jar_ , _.war_ , or _.rar_ file (as appropriate
to its type), together with an optional alternate deployment descriptor
external to the application or standalone Jakarta EE module. If the
application is delivered as a _.ear_ , an enterprise bean module
delivered as a _.jar_ file, a web application delivered as a _.war_
file, or an application client delivered as a _.jar_ file, the
deployment tool must be able to deploy the application such that the
Jakarta classes in the application are in a separate namespace from classes
in other Jakarta applications. Typically this will require the use of a
separate class loader for each application. Standalone resource adapters
delivered in _.rar_ files and standalone class libraries delivered in
_.jar_ files that become installed libraries will of necessity appear in
the class namespaces of applications that use them, and may appear in
the class namespace of any application depending on the level of
isolation supported by the Jakarta EE product.

As described in
<<a149, Jakarta EE Product Packaging>>, the Jakarta EE product might depend on external services to
meet the requirements of this specification. While the Jakarta EE product
is not required to assure the availability of these services, it is
required to ensure that these services have been configured for use.
Deployment of applications must fail if such required services have not
been configured for use.

Deployment may provide an option that
controls whether or not an application is attempted to be started during
deployment. If no such option is provided or if the option to start the
application is specified, and if deployment is successful, the
application modules must be initialized as specified in section
<<a3201, Module Initialization>>
and the application must be started.

If the application is attempted to be started
during deployment, the Jakarta Servlet and Jakarta Enterprise Beans containers must be initialized
during deployment. Such initialization must include CDI initialization.
If initialization fails, deployment must fail.

If the application is not attempted to be
started during deployment, these containers must not be initialized
during deployment.

In all cases, the deployment and
initialization of a Jakarta EE application must be complete before the
container delivers client requests to any of the application’s
components. The container must first initialize all startup-time
singleton session bean components before delivering any requests to
enterprise bean components. Containers must deliver requests to web
components and resource adapters only after initialization of the
component has completed.

The optional Jakarta EE Deployment API describes
how a product-independent deployment tool accepts plugins for a specific
Jakarta EE product, and how the tool and those plugins cooperate to deploy
Jakarta EE applications. The requirements in this specification that refer
to a deployment tool are meant to refer to the combination of any
vendor-provided product-independent deployment tool and the
vendor-specific deployment plugin for this tool, as well as any other
vendor-specific deployment tools provided with the Jakarta EE product.

Typically a deployment tool will copy the
deployed application or module to a product-specific location, along
with the configuration settings and customizations specified by the
Deployer. In some cases a deployment tool might include Application
Assembly functionality as well, allowing the Deployer to construct,
modify, or customize the application before deployment. Still, it must
be possible to deploy a portable Jakarta EE application, module, or library
containing no product-specific deployment information without modifying
the original files or artifacts that the Deployer specified to the
deployment tool.

The deployment tools for Jakarta EE containers
must validate the deployment descriptors against the Jakarta EE deployment
descriptor schemas or DTDs that correspond to the deployment descriptors
being processed. The appropriate schema or DTD is chosen by analyzing
the deployment descriptor to determine which version it claims to
conform to. Validation errors must cause an error to be reported to the
Deployer. The deployment tool may allow the Deployer to correct the
error and continue deployment. Note that the deployment descriptor
version refers only to the version of the XML schema or DTD against
which the descriptor is to be validated. It does not provide any
information as to what version of the Jakarta EE the application
is written to.

Some deployment descriptors are optional. The
required deployment information is determined by using default rules or
by annotations present on application class files. Some deployment
descriptors that are included in an application may exist in either
complete or incomplete form. A complete deployment descriptor provides a
complete description of the deployment information; a deployment tool
must not examine class files for this deployment information. An
incomplete deployment descriptor provides only a subset of the required
deployment information; a deployment tool must examine the application
class files for annotations that specify deployment information.

If annotations are being processed (as
required by <<a3318, Deployment Descriptor Processing Requirements>>, Jakarta Servlet Table 8-1, and Jakarta Enterprise Beans Tables
16 and 17), _at least_ all of the classes specified in
<<a651, Component classes supporting injection>> must be scanned for annotations that specify
deployment information. As specified in section
<<a3179, Deploying a Jakarta EE Application>>, all classes that can be used by the application may
optionally be scanned for these annotations. (These are the annotations
that specify information equivalent to what can be specified in a
deployment descriptor. This requirement says nothing about the
processing of annotations that were defined for other purposes.) These
annotations may appear on classes, methods, and fields. All resources
specified by resource definition annotations must be created. All
resource reference annotations must result in JNDI entries in the
corresponding namespace. If the corresponding namespace is not available
to the class declaring or inheriting the reference, the resulting
behavior is undefined. Future versions of this specification may alter
this behavior.

Any deployment information specified in a
deployment descriptor overrides any deployment information specified in
an application’s class files. The Jakarta EE component specifications,
including this specification, describe when deployment descriptors are
optional and which deployment descriptors may exist in either complete
or incomplete form. The attribute _metadata-complete_ is used in the
deployment descriptor to specify whether the descriptor is complete. The
_metadata-complete_ attribute in the standard deployment descriptors
effects _only_ the scanning of annotations that specify deployment
information, including web services deployment information. It has no
impact on the scanning of other annotations.

The scope of the _metadata-complete_
attribute is the descriptor it appears in. For historical reasons, the
_webservices.xml_ deployment descriptor does not have its own
_metadata-complete_ attribute; instead, it defers to the value of the
_metadata-complete_ attribute in the module’s deployment descriptor.
Specifications that define their own additional deployment descriptors
should provide a _metadata-complete_ attribute of their own, if deemed
useful, with the appropriate semantics.

==== Deploying a Stand-Alone Jakarta EE Module

This section specifies the requirements for
deploying a stand-alone Jakarta EE module.

. The deployment tool must first read the Jakarta
EE module deployment descriptor if provided externally to the package or
if present in the package. See the component specifications for the
required location and name of the deployment descriptor for each
component type.
. If the deployment descriptor is absent, or
is present and is a Java EE 5 or later version descriptor and the
_metadata-complete_ attribute is not set to _true_ , the deployment tool
must examine all the class files in the application package. Any
annotations that specify deployment information must be logically merged
with the information in the deployment descriptor (if present). The
correspondence of annotation information with deployment descriptor
information, as well as the overriding rules, are described in this and
other Jakarta EE specifications. The result of this logical merge process
provides the deployment information used in subsequent deployment steps.
Note that there is no requirement for the merge process to produce a new
deployment descriptor, although that might be a common implementation
technique.
. When deploying a standalone module, the
module name is used as the application name. The deployment tool must
ensure that the application name is unique in the application server
instance. If the name is not unique, the deployment tool may
automatically choose a unique name or allow the Deployer to choose a
unique name, but must not fail the deployment. This ensures that
existing modules continue to be deployable.
. The deployment tool must deploy all of the
components listed in the Jakarta EE module deployment descriptor, or marked
via annotations and discovered as described in the previous requirement,
according to the deployment requirements of the respective Jakarta EE
component specification. If the module is a type that contains JAR
format files (for example, web and connector modules), all classes in
_.jar_ files within the module referenced from other JAR files within
the module using the _Class-Path_ manifest header must be included in
the deployment. If the module, or any JAR format files within the
module, declares a dependency on an installed library, that dependency
must be satisfied.
. The deployment tool must allow the Deployer
to configure the container to provide the resources and configuration
values needed for each component. The required resources and
configuration parameters are specified in the deployment descriptor or
via annotations discovered in requirement 2.
. The deployment tool must allow the Deployer
to deploy the same module multiple times, as multiple independent
applications, possibly with different configurations. For example, the
enterprise beans in an ejb-jar file might be deployed multiple times
under different JNDI names and with different configurations of their
resources.

[[a3179]]
==== Deploying a Jakarta EE Application

This section specifies the requirements for
deploying a Jakarta EE application.

. The deployment tool must first read the Jakarta
EE application deployment descriptor provided externally to the
application _.ear_ file or from within the application _.ear_ file (
_META-INF/application.xml_ ). If the deployment descriptor is present,
it fully specifies the modules included in the application. If no
deployment descriptor is present, the deployment tool uses the following
rules to determine the modules included in the application.
. All files in the application package with a
filename extension of _.war_ are considered web modules. The context
root of the web module is the module name (see
<<a2904, Component Creation>>).
. All files in the application package with a
filename extension of _.rar_ are considered resource adapters.
. A directory named _lib_ is considered to be
the library directory, as described in
<<a2948, Bundled Libraries>>.
. For all files in the application package
with a filename extension of _.jar_ , but not contained in the _lib_
directory, do the following:
. If the _.jar_ file contains a
_META-INF/MANIFEST.MF_ file with a _Main-Class_ attribute, or contains a
_META-INF/application-client.xml_ file, consider the .jar file to be an
application client module.
. If the _.jar_ file contains a
_META-INF/ejb-jar.xml_ file, or contains any class with an Jakarta Enterprise Beans
component-defining annotation ( _Stateless_ , etc.), consider the .jar
file to be an Jakarta Enterprise Beans module.
. All other _.jar_ files are ignored unless
referenced by a JAR file discovered above using one of the JAR file
reference mechanisms such as the _Class-Path_ header in a manifest file.
. The deployment tool must ensure that the
application name is unique in the application server instance. If the
name is not unique, the deployment tool may automatically choose a
unique name or allow the Deployer to choose a unique name, but must not
fail the deployment. This ensures that existing applications continue to
be deployable.
. The deployment tool must open each of the
Jakarta EE modules listed in the Jakarta EE application deployment descriptor
or discovered using the rules above and read the Jakarta EE module
deployment descriptor, if present in the package. See the Enterprise
Jakarta Beans, Jakarta Servlet, Jakarta Connector and application client
specifications for the required location and name of the deployment
descriptor for each component type. Deployment descriptors are optional
for all module types. (The application client specification is
<<a3294, Application Clients>>.)
. If the module deployment descriptor is
absent, or is present and is a Java EE 5 or later version descriptor and
the _metadata-complete_ attribute is not set to _true_ , the deployment
tool must examine all the class files in the application package that
can be used by the module (that is, all class files that are included in
the _.ear_ file and can be referenced by the module, such as the class
files included in the module itself, class files referenced from the
module by use of a _Class-Path_ reference, class files included in the
library directory, etc.). Any annotations that specify deployment
information must be logically merged with the information in the
deployment descriptor (if present). Note that the presence of
component-declaring annotations in shared artifacts, such as libraries
in the library directory and libraries referenced by more than one
module through _Class-Path_ references, can have unintended and
undesirable consequences and is not recommended. The correspondence of
annotation information with deployment descriptor information, as well
as the overriding rules, are described in this and other Jakarta EE
specifications. The result of this logical merge process provides the
deployment information used in subsequent deployment steps. Note that
there is no requirement for the merge process to produce a new
deployment descriptor, although that might be a common implementation
technique.
. The deployment tool must install all of the
components described by each module deployment descriptor, or marked via
annotations and discovered as described in the previous requirement,
into the appropriate container according to the deployment requirements
of the respective Jakarta EE component specification. All classes in _.jar_
files or directories referenced from other JAR files using the
_Class-Path_ manifest header must be included in the deployment. If the
_.ear_ file, or any JAR format files within the _.ear_ file, declares a
dependency on an installed library, that dependency must be satisfied.
. The deployment tool must allow the Deployer
to configure the container to provide the resources and configuration
values needed for each component. The required resources and
configuration parameters are specified in the deployment descriptor or
via annotations discovered in requirement 3.
. The deployment tool must allow the Deployer
to deploy the same Jakarta EE application multiple times, as multiple
independent applications, possibly with different configurations. For
example, the enterprise beans in an ejb-jar file might be deployed
multiple times under different JNDI names and with different
configurations of their resources.
. When presenting security role descriptions to
the Deployer, the deployment tool must use the descriptions in the Jakarta
EE application deployment descriptor rather than the descriptions in any
module deployment descriptors for security roles with the same name.
However, for security roles that appear in a module deployment
descriptor but do not appear in the application deployment descriptor,
the deployment tool must use the description provided in the module
deployment descriptor.

[NOTE]
====

The jakarta name is a trademarked name that has restrictions on its usage. For Jakarta EE, the specification
projects produce APIs that utilize the jakarta.* namespace. As defined in the Jakarta EE Specification Process 1.3, APIs
artifacts (API jars, javadoc, schemas) produced by a specification project are the only artifacts that must make use of the
jakarta.* package namespace. The jakarta namespace must not be used for any deployment, including applications, TCKs, tools,
libraries or any other assets. Attempting to deploy an application under the jakarta.* package namespace may result in deployment
error or other unspecified behavior.
====

==== Deploying a Library

This section specifies the requirements for
deploying a library.

. The deployment tool must record the
extension name and version information from the manifest file of the
library JAR file. The deployment tool must make the library available to
other Jakarta EE deployment units that request it according to the version
matching rules described in the Optional Package Versioning
specification. Note that the library itself may include dependencies on
other libraries and these dependencies must also be satisfied.
. The deployment tool must make the library
available with at least the same security permissions as any application
or module that uses it. The library may be installed with the full
security permissions of the container.
. Not all libraries will be deployable on all
Jakarta EE products at all times. Libraries that conflict with the
operation of the Jakarta EE product may not be deployable. For example, an
attempt to deploy an older version of a library that has subsequently
been included in the Jakarta EE specification may be rejected.
Similarly, deployment of a library that is also used in the
implementation of the Jakarta EE product may be rejected. Deployment of a
library that is in active use by an application may be rejected.

[[a3201]]
==== Module Initialization

After a successful deployment, all the
modules of an application other than application client modules are
initialized. The specifications for the different module types describe
the steps required to initialize a module. By default, the order of
initialization of modules in an application is unspecified. In rare
cases it may be important that modules are initialized in a certain
order, for example, if a component in one modules uses a component in
another module during its initialization. An application can declare
that modules must be initialized in the order they’re listed in the
application deployment descriptor by including the
_<initialize-in-order>true</initialize-in-order>_ element in the
application deployment descriptor. If the application deployment
descriptor specifies a module initialization order that conflicts with
the initialization order specified by any of the modules (for example,
by the use of the Jakarta Enterprise Beans _DependsOn_ annotation), the deployment tool must
report an error. Application client modules are initialized on their own
schedule, typically when an end user invokes them; as such, they are
excluded from any initialization ordering requirements.

[[a3203]]
=== Jakarta EE Application XML Schema

The XML grammar for a Jakarta EE application
deployment descriptor is defined by the Jakarta EE application schema. The
root element of the deployment descriptor for a Jakarta EE application is
_application_ . The granularity of composition for Jakarta EE application
assembly is the Jakarta EE module. A Jakarta EE application deployment
descriptor contains a name and description for the application and the
URI of a UI icon for the application, as well a list of the Jakarta EE
modules that comprise the application. The content of the XML elements
is in general case sensitive. This means, for example, that
_<role-name>Manager</role-name>_ is a different role than
_<role-name>manager</role-name>_ .

All valid Jakarta EE application deployment
descriptors must conform to the XML Schema definitions
as defined by <<a3447, Previous Version Deployment Descriptors>>. 
The deployment descriptor must be named
_META-INF/application.xml_ in the _.ear_ file. Note that this name is
case-sensitive. The XML Schema located at
_https://jakarta.ee/xml/ns/jakartaee/application_11.xsd_ defines the XML
grammar for a Jakarta EE application deployment descriptor.

<<a3208, Jakarta EE Application XML Schema Structure>> shows a graphic representation
of the structure of the Jakarta EE application XML schema.

[[a3208]]
.Jakarta EE Application XML Schema Structure
image::JavaEEapplication_schema_7.svg[]

=== Common Jakarta EE XML Schema Definitions

The XML Schema located at
_https://jakarta.ee/xml/ns/jakartaee/jakartaee_11.xsd_ defines types that are
used by many other Jakarta EE deployment descriptor schemas, both in this
specification and in other specifications.
