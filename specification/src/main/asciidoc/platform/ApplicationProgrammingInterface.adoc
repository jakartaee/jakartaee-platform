[[a2133]]
== Application Programming Interface

This chapter describes API requirements
for the Jakarta™ Platform, Enterprise Edition (Jakarta EE). Jakarta EE requires
the provision of a number of APIs for use by Jakarta EE applications,
starting with the core Java APIs and including many additional Java
technologies.


[[a2136]]
=== Required APIs

Jakarta EE application components execute in
runtime environments provided by the containers that are a part of the
Jakarta EE platform. The full Jakarta EE platform supports three types of
containers corresponding to Jakarta EE application component types:
application client containers; web containers for
servlets, Jakarta Server Pages, Jakarta Server Faces applications,
Jakarta RESTful Web Services applications;
and enterprise bean containers. A Jakarta EE profile may support only a subset
of these component types, as defined by the individual Jakarta EE profile
specification.

The per-technology requirements in this
chapter apply to any Jakarta EE product that includes the technology. Note
that even though a Jakarta EE profile might not require support for a
particular technology, a Jakarta EE product based on that Jakarta EE profile
might nonetheless include support for the technology. In such a case,
the requirements for that technology described in this chapter would
apply.

[[a3537]]
==== Java Compatible APIs

The containers provide all application
components with at least the Java Platform, Standard Edition, v11 (Java
SE) APIs. Containers may provide newer versions of the Java SE platform,
provided they meet all the Jakarta EE platform requirements as outlined below.

===== Java SE Enterprise Technologies

The Java SE 17 platform includes a number of enterprise technologies. Except
for technologies noted in this specification as being optional, containers
must provide all application components with the APIs associated with these
technologies. If a newer version of the Java SE platform provided by
a container has removed some of these technologies, the container must
provide these technologies in some other manner.

The Java SE 17 platform includes the following enterprise technologies:

* Java IDL footnote:[Removed from Java SE 11. Support for Java IDL is optional Product vendors that wish to support Java IDL on a Java SE version that does not provide the Java IDL APIs must otherwise provide those APIs to application components. ]
* JDBC
* RMI-JRMP
* javax.rmi.PortableRemoteObject footnote:[Removed from Java SE 11. Product vendors that support the optional Enterprise Beans 2.x API group must ensure that the javax.rmi.PortableRemoteObject class is available to application components.]
* JNDI
* JAXP
* StAX
* JAAS
* JMX
* JAX-WS footnote:javaremovalopt[Removed from Java SE 11. Since Jakarta EE 9 this optional technology is provided under a Jakarta EE specification. If the technology is provided, the container must provide the Jakarta EE version of the technology. See <<a2161, Required Jakarta Technologies>>.]
* JAXB footnote:javaremovalopt[]
* JAF footnote:javaremovalreq[Removed from Java SE 11. Since Jakarta EE 9 this technology is provided under a Jakarta EE specification. The container must provide the Jakarta EE version of the technology. See <<a2161, Required Jakarta Technologies>>.]
* SAAJ footnote:javaremovalopt[]
* Common Annotations footnote:javaremovalreq[]

Note that a number of the enterprise technologies provided
by Java SE 8 are now provided by Jakarta EE specifications and are
included in the list of <<a2161, Required Jakarta Technologies>>.

The specifications for the Java SE APIs are
available at _https://docs.oracle.com/javase/17/docs/_ .

===== Java Module Names
Java(TM) SE 9 introduced the concept of a modularity system, known as the Java Platform Module System (JPMS).
Defined modules need a _name_ to allow for references by other modules.
Jakarta EE 10 does not define a module naming convention.
However, some Java EE(TM) 8 and Jakarta EE features had already defined their corresponding module names.
Due to these previous module naming efforts, the following guidelines are strongly suggested for Jakarta EE 9:

* If an Automatic Module Name (MANIFEST) already exists, update the name to use the ‘jakarta’ prefix to be consistent with the package rename requirement.
Do not create _new_ Automatic Module Names for Jakarta EE 9.  
* If a module-info.class already exists, update the name to use the ‘jakarta’ prefix to be consistent with the package rename requirement.
Do not create _new_ module-info.class files for Jakarta EE 9. 
* If neither Automatic Module Names or module-info.class exists, then leave as-is.

These guidelines allow existing module names to get to a consistent state with the least amount of disruption.
Any existing module names may need to be updated once specific module name requirements are established in a future release.

[[a2161]]
==== Required Jakarta Technologies

The full Jakarta EE platform also provides a
number of technologies in each of the containers defined by this
specification. <<a2159, Jakarta EE Technologies>> indicates the required technologies.
Each Jakarta EE profile specification will include a similar table
describing which technologies are required for the profile. Note that
some technologies are marked Optional, as described in the next
section.  Please see the table in the section Application Programming
Interface for the specific versions required for each component.

*Note:* Jakarta EE 9 introduced the concept of "removed" technologies.
This is the final stage of a technology's lifecycle where the technology is
officially removed from the Jakarta EE Platform.
This is a stronger statement than making a technology "optional", since a "removed"
technology will no longer be maintained for future versions of the Platform.
<<a2333, Removed Jakarta Technologies>> documents these removed technologies.

[[a2159]]
[cols=4, options=header]
.Jakarta EE Technologies
|===
|Jakarta EE Technology
|App Client
|Web
|Enterprise Beans

|Activation
|Y
|Y
|Y

|Annotations
|Y
|Y
|Y

|Authentication
|N
|Y
|Y

|Authorization
|N
|Y
|Y

|Batch
|N
|Y
|Y

|Concurrency
|N
|Y
|Y

|Connectors
|N
|Y
|Y

|Contexts and Dependency Injection
|Y
|Y
|Y

|Data
|N
|Y
|Y

|Debugging Support for Other Languages
|N
|Y
|N

|Dependency Injection
|Y
|Y
|Y

|Enterprise Beans
|Y footnote:[Client APIs only.]
|Y
|Y

|Expression Language
|N
|Y
|N

|Interceptors
|Y
|Y
|Y

|JSON Binding
|Y
|Y
|Y

|JSON Processing
|Y
|Y
|Y

|Mail
|Y
|Y
|Y

|Messaging
|Y
|Y
|Y

|Persistence
|Y
|Y
|Y

|RESTful Web Services
|N
|Y
|N

|Security
|N
|Y
|Y

|Server Faces
|N
|Y
|N

|Server Pages
|N
|Y
|N

|Servlet
|N
|Y
|N

|Standard Tag Library
|N
|Y
|N

|Transactions
|N
|Y
|Y

|Validation
|Y
|Y
|Y

|WebSocket
|N
|Y
|N

|===

All classes and interfaces required by
the specifications for the APIs must be provided by the Jakarta EE
containers indicated above. In some cases, a Jakarta EE product is not
required to provide objects that implement interfaces intended to be
implemented by an application server, nevertheless, the definitions of
such interfaces must be included in the Jakarta EE platform. If an
implementation includes support for a technology marked as Optional,
that technology must be supported in the containers specified above. If
a product implementation does not support a technology marked as
Optional, it must not include the APIs for that
technology.footnote:[Note that a component specification is permitted to specify
an exception to this in order to accommodate interface type dependencies—for example,
the Jakarta™ Enterprise Beans SessionContext dependency on the
_jakarta.xml.rpc.handler.MessageContext_ type.]

If a container supports Java SE 17 or a newer version of the Java SE platform, than all classes and interfaces provided by the container to satisfy the platform requirements listed above, must be compiled with the Java SE 17 source and class level.

[[a2841]]
==== Platform Prospective Specifications

During the development cycle for the current version of the Jakarta EE specification, the platform project considered several component specifications for inclusion in the platform. A consensus could not be reached on including these specifications in the platform. These specifications are considered as prospects for inclusion in a future version of the Platform specification.

* https://jakarta.ee/specifications/mvc/[Jakarta MVC]

[[a2331]]
==== Optional Jakarta Technologies

As the Jakarta EE specification has evolved,
some of the technologies originally included in Jakarta EE are no longer as
relevant as they were when they were introduced to the platform. The
Jakarta EE Platform Specification Project follows a process similar to the one first defined by the Java SE
expert group ( _https://mreinhold.org/blog/removing-features_ ) to stabilize and remove
technologies from the platform in a careful and orderly way that
minimizes the impact to developers using these technologies, while
allowing the platform to grow even stronger.

An individual specification can have optional features. However when a component specification is included in the Platform, Web Profile, and Core Profile, an optional feature must be explicitly declared as required, otherwise it is not required. For complete normative details, see https://jakarta.ee/committees/specification/versioning/#allowedchanges[Jakarta EE Specification Versioning, Change, and Deprecation Process].

[[a2333]]
==== Removed Jakarta Technologies
Jakarta EE 9 introduced the concept of "removed" technologies.
This is the final stage of a technology's lifecycle where the technology is
officially *removed* from the Jakarta EE Platform.
This is a stronger statement than making a technology "optional", since a "removed"
technology will no longer be maintained for future versions of the Platform.

The following Jakarta EE Technologies were removed from the Jakarta EE Platform.
[[a2160]]
[cols=2, options=header]
.Jakarta EE Technologies
|===
|Jakarta EE Technology
|Status

|Embeddable EJB Container (Jakarta Enterprise Beans, Core Features 4.0, Chapter 17)
|Removed in Jakarta EE 10

|Entity Beans, both Container and Bean Managed Persistence (Jakarta Enterprise Beans 4.0, Optional Features, Chapters 3 - 7)
|Removed in Jakarta EE 10

|Enterprise Web Services
|Removed in Jakarta EE 11

|SOAP with Attachments
|Removed in Jakarta EE 11

|XML Binding
|Removed in Jakarta EE 11

|XML Web Services
|Removed in Jakarta EE 11
|===

[[a2339]]
=== Java Platform, Standard Edition (Java SE) Requirements

==== Programming Restrictions

The Jakarta EE programming model divides
responsibilities between Application Component Providers and Jakarta EE
Product Providers: Application Component Providers focus on writing
business logic and the Jakarta EE Product Providers focus on providing a
managed system infrastructure in which the application components can be
deployed.

This division leads to a restriction on the
functionality that application components can contain. If application
components contain the same functionality provided by Jakarta EE system
infrastructure, there are clashes and mis-management of the
functionality.

For example, if enterprise beans were
allowed to manage threads, the Jakarta EE platform could not manage the
life cycle of the enterprise beans, and it could not properly manage
transactions.

==== Jakarta EE Security Manager Related Requirements

The Jakarta EE 11 release removes the requirement to use a Java 
security manager.

==== Additional Requirements

[[a2523]]
===== Networking

The Java SE platform includes a pluggable
mechanism for supporting multiple URL protocols through the
_java.net.URLStreamHandler_ class and the
_java.net.URLStreamHandlerFactory_ interface.

The following URL protocols must be supported:

*  _file_ _:_ Only reading from a _file_ URL
need be supported. That is, the corresponding _URLConnection_ object’s
_getOutputStream_ method may fail with an _UnknownServiceException_ .
File access is restricted according to the permissions described above.
*  _http_ _:_ Version 1.1 of the HTTP protocol
must be supported. An _http_ URL must support both input and output.
*  _https_ : SSL version 3.0 and TLS version 1.2
must be supported by _https_ URL objects. Both input and output must be
supported.

The Java SE platform also includes a mechanism
for converting a URL’s byte stream to an appropriate object, using the
_java.net.ContentHandler_ class and _java.net.ContentHandlerFactory_
interface. A _ContentHandler_ object can convert a MIME byte stream to
an object. _ContentHandler_ objects are typically accessed indirectly
using the _getContent_ method of _URL_ and _URLConnection_ .

When accessing data of the following MIME types
using the _getContent_ method, objects of the corresponding Java type
listed in <<a2531, Java Type of Objects Returned When Using the getContent Method>> must be returned.

[[a2531]]
[cols=2, options=header]
.Java Type of Objects Returned When Using the getContent Method
|===
|MIME Type
|Java Type

|image/gif
|java.awt.Image

|image/jpeg
|java.awt.Image

|image/png
|java.awt.Image
|===

Many environments will use HTTP proxies rather
than connecting directly to HTTP servers. If HTTP proxies are being used
in the local environment, the HTTP support in the Java SE platform
should be configured to use the proxy appropriately. Application
components must not be required to configure proxy support in order to
use an _http_ URL.

Most enterprise environments will include a
firewall that limits access from the internal network (intranet) to the
public Internet, and vice versa. It is typical for access using the HTTP
protocol to pass through such firewalls, perhaps by using proxy servers.
It is not typical that general TCP/IP traffic, including RMI-JRMP, and
RMI-IIOP, can pass through firewalls.

These considerations have implications on the
use of various protocols to communicate between application components.
This specification requires that HTTP access through firewalls be
possible where local policy allows. Some Jakarta EE products may provide
support for tunneling other communication through firewalls, but this is
neither specified nor required. Application developers should consider
the impact of these issues in the design of applications, particularly
in view of cloud environments, where a cloud platform provider might
only allow HTTP-based access.

===== JDBC™ API

The JDBC API, which is part of the Java SE
platform, allows for access to a wide range of data storage systems. The
Java SE platform, however, does not require that a system meeting the
Java Compatible™ quality standards provide a database that is accessible
through the JDBC API.

To allow for the development of portable
applications, the Jakarta EE specification does require that such a
database be available and accessible from a Jakarta EE product through the
JDBC API. Such a database must be accessible from web components,
enterprise beans, and application clients. In addition, the driver for 
the database must meet the JDBC Compatible requirements in the JDBC specification.

Jakarta EE applications should not attempt to
load JDBC drivers directly. Instead, they should use the technique
recommended in the JDBC specification and perform a JNDI lookup to
locate a _DataSource_ object. The JNDI name of the _DataSource_ object
should be chosen as described in
<<a1120, Resource Manager Connection Factory References>>. The Jakarta EE platform must be able to
supply a _DataSource_ that does not require the application to supply
any authentication information when obtaining a database connection. Of
course, applications may also supply a user name and password when
connecting to the database.

When a JDBC API connection is used in an
_enterprise bean_ , the transaction characteristics will typically be
controlled by the container. The component should not attempt to change
the transaction characteristics of the connection, commit the
transaction, roll back the transaction, or set autocommit mode. Attempts
to make changes that are incompatible with the current transaction
context may result in a _SQLException_ being thrown. The Jakarta Enterprise Beans
specification contains the precise rules for _enterprise beans._

Note that the same restrictions apply when a
component creates a transaction using the Jakarta Transactions _UserTransaction_
interface. The component should not attempt the operations listed above
on the JDBC _Connection_ object that would conflict with the transaction
context.

Drivers supporting the JDBC API in a Jakarta EE
environment must meet the JDBC API Compliance requirements as specified
in the JDBC specification.

The JDBC API includes APIs for connection
naming via JNDI, connection pooling, and distributed transaction
support. The connection pooling and distributed transaction features are
intended for use by JDBC drivers to coordinate with an application
server. Jakarta EE products are not required to support the application
server facilities described by these APIs, although they may prove
useful.

The Connector architecture defines an SPI
that essentially extends the functionality of the JDBC SPI with
additional security functionality, and a full packaging and deployment
functionality for resource adapters. A Jakarta EE product that supports the
Connector architecture must support deploying and using a JDBC driver
that has been written and packaged as a resource adapter using the
Connector architecture.

Every release of Jakarta EE declares a minimum required version of Java SE. For discussion, let this be Java SE N. Compatible implementations of Jakarta EE must support the latest version of the JDBC API mentioned in the Java SE N javadocs for the package `java.sql`. These javadocs typically have a link to the corresponding specification at `jcp.org`. 

[[a2553]]
===== RMI-JRMP

JRMP is the Java technology-specific Remote
Method Invocation (RMI) protocol. The Jakarta EE security restrictions
typically prevent all application component types except application
clients from creating and exporting an RMI object, but all Jakarta EE
application component types can be clients of RMI objects.

===== RMI-IIOP

The RMI-IIOP subsystem is composed of APIs that allow for the
use of RMI-style programming that is independent of the underlying
protocol.  Implementations of these APIs may support the Java SE native RMI
protocol (JRMP), the CORBA IIOP protocol, or any custom protocol that is
compatible with the RMI programming restrictions.

NOTE: The requirements in this section only apply to Jakarta EE products that
include an Enterprise Beans container with support for remote interfaces.

Jakarta EE applications use the RMI-IIOP APIs when accessing
remote Enterprise Beans components, as described in the Jakarta Enterprise
Beans 4.0 specification.  This allows Enterprise Beans and their clients to be
protocol independent and portable to Jakarta EE implementations that may use
CORBA/IIOP, RMI, or any other custom protocol.

Requirements for distributed interoperability over CORBA/IIOP have been removed in
Jakarta Enterprise Beans 4.0. Use of the narrow method of `javax.rmi.PortableRemoteObject`
and references to `org.omg.ORB` in the Platform are slated for removal in a future release.

Jakarta EE implementations may use CORBA/IIOP as their underlying protocol, however,
such support is implementation-specific and no longer a guarantee of the Jakarta
EE platform.

===== JNDI

A Jakarta EE product that supports the following
types of objects must be able to make them available in the
application’s JNDI namespace: _EJBHome_ objects, _EJBLocalHome_ objects,
Enterprise Beans business interface objects, Jakarta Transactions _UserTransaction_ objects, JDBC API
_DataSource_ objects, JMS _ConnectionFactory_ and _Destination_ objects,
Jakarta Mail _Session_ objects, _URL_ objects, resource manager
_ConnectionFactory_ objects (as specified in the Connector
specification), _ORB_ objects, _EntityManagerFactory_ objects, and other
Java language objects as described in
<<a567, Resources, Naming, and Injection>>. The JNDI implementation in a Jakarta EE product must be
capable of supporting all of these uses in a single application
component using a single JNDI _InitialContext_ . Application components
will generally create a JNDI _InitialContext_ using the default
constructor with no arguments. The application component may then
perform lookups on that _InitialContext_ to find objects as specified
above.

The names used to perform lookups for Jakarta EE
objects are application dependent. The application component’s metadata
annotations and/or deployment descriptor are used to list the names and
types of objects expected. The Deployer configures the JNDI namespace to
make appropriate components available. The JNDI names used to lookup
such objects must be in the JNDI _java:_ namespace. See
<<a567, Resources, Naming, and Injection>> for details.

Particular names are defined by this
specification for the cases when the Jakarta EE product includes the
corresponding technology. For all application components that have
access to the Jakarta Transaction _UserTransaction_ interface, the appropriate
_UserTransaction_ object can be found using the name
_java:comp/UserTransaction_ . In all containers, application components may lookup a CORBA _ORB_ instance
using the name _java:comp/ORB_ . For all application components that
have access to the CDI _BeanManager_ interface, the appropriate
_BeanManager_ object can be found using the name _java:comp/BeanManager_
. For all application components that have access to the Validation
APIs, the appropriate _Validator_ and _ValidatorFactory_ objects can be
found using the names _java:comp/Validator_ and
_java:comp/ValidatorFactory_ respectively.

The name used to lookup a particular Jakarta EE
object may be different in different application components. In general,
JNDI names can not be meaningfully passed as arguments in remote calls
from one application component to another remote component (for example,
in a call to an _enterprise bean_ ).

The JNDI _java:_ namespace is commonly
implemented as symbolic links to other naming systems. Different
underlying naming services may be used to store different kinds of
objects, or even different instances of objects. It is up to a Jakarta EE
product to provide the necessary JNDI service providers for accessing
the various objects defined in this specification.

This specification requires that the Jakarta EE
platform provide the ability to perform lookup operations as described
above. Different JNDI service providers may provide different
capabilities, for instance, some service providers may provide only
read-only access to the data in the name service.

A Jakarta EE product may be required to provide
a COSNaming name service to meet the Jakarta Enterprise Beans interoperability
requirements.  In such a case, a COSNaming JNDI service provider must be available
through the web, Enterprise Beans, and application client containers.

A COSNaming JNDI service provider is a part
of the Java SE 8 SDK and JRE from Oracle, but is not a required
component of the Java SE specification. The COSNaming JNDI service
provider specification is available at
_https://docs.oracle.com/javase/8/docs/technotes/guides/jndi/jndi-cos.html_
.

See
<<a567, Resources, Naming, and Injection>> for the complete naming requirements for the Jakarta EE
platform. The JNDI specification is available at
_https://docs.oracle.com/javase/8/docs/technotes/guides/jndi/index.html_
.

===== Context Class Loader

This specification requires that Jakarta EE
containers provide a per thread context class loader for the use of
system or library classes in dynamically loading classes provided by the
application. The Jakarta Enterprise Beans specification requires that all
Jakarta Enterprise Beans client containers provide a per thread context class
loader for dynamically loading system value classes. The per thread context
class loader is accessed using the _Thread_ method _getContextClassLoader_ .

The classes used by an application will
typically be loaded by a hierarchy of class loaders. There may be a top
level application class loader, an extension class loader, and so on,
down to a system class loader. The top level application class loader
delegates to the lower class loaders as needed. Classes loaded by lower
class loaders, such as portable Jakarta Enterprise Beans system value classes, need to be
able to discover the top level application class loader used to
dynamically load application classes.

This specification requires that containers
provide a per thread context class loader that can be used to load top
level application classes as described above. See
<<a2966, Dynamic Class Loading>>
for recommendations for libraries that dynamically load classes.

===== Jakarta Authentication Requirements

All enterprise beans containers and all web containers
must support the use of the Jakarta Authentication APIs as specified in the Connector
specification. All application client containers must support use of the
Jakarta Authentication APIs.

The Jakarta Authentication specification is
available at _https://jakarta.ee/specifications/authentication/_ .


===== Logging API Requirements

The Logging API provides classes and
interfaces in the _java.util.logging_ package that are the Java™
platform’s core logging facilities. This specification does not require
any additional support for logging. A Jakarta EE application typically will
not have the _LoggingPermission_ necessary to control the logging
configuration, but may use the logging API to produce log records. A
future version of this specification may require that the Jakarta EE
containers use the logging API to log certain events.

===== Preferences API Requirements

The Preferences API in the _java.util.prefs_
package allows applications to store and retrieve user and system
preference and configuration data. A Jakarta EE application typically will
not have the _RuntimePermission("preferences")_ necessary to use the
Preferences API. This specification does not define any relationship
between the principal used by a Jakarta EE application and the user
preferences tree defined by the Preferences API. A future version of
this specification may define the use of the Preferences API by Jakarta EE
applications.

=== Enterprise Beans 4.0 Requirements

This specification requires that a  Jakarta EE
product provide support for _enterprise beans_ as specified in the Jakarta Enterprise
Beans specification. The Jakarta Enterprise Beans specification is available at
_https://jakarta.ee/specifications/enterprise-beans/_ .

A Jakarta EE product may support multiple object systems (for example,
RMI-IIOP, RMI-JRMP, gRPC, protobuf, Thrift).  There is no explicit
requirement that a Jakarta EE product support any specific protocol,
such as CORBA/IIOP, or provide distributed interoperability between
products.

In a Jakarta EE product that includes both an
enterprise beans container and a web container, both containers are required to
support access to local enterprise beans. No support is provided for
access to local enterprise beans from the application client container.

=== Servlet 6.1 Requirements

The Jakarta Servlet specification defines the
packaging and deployment of web applications, whether standalone or as
part of a Jakarta EE application. The Servlet specification also addresses
security, both standalone and within the Jakarta EE platform. These
optional components of the Servlet specification are requirements of the
Jakarta EE platform.

The Servlet specification includes additional
requirements for web containers that are part of a Jakarta EE product and a
Jakarta EE product must meet these requirements as well.

The Servlet specification defines
distributable web applications. To support Jakarta EE applications that are
distributable, this specification adds the following requirements.

Web containers must support Jakarta EE
distributable web applications placing objects of any of the following
types (when supported by the Jakarta EE product) into a
_jakarta.servlet.http.HttpSession_ object using the _setAttribute_ or
_putValue_ methods:

*  _java.io.Serializable_
*  _jakarta.ejb.EJBObject_
*  _jakarta.ejb.EJBHome_
*  _jakarta.ejb.EJBLocalObject_
*  _jakarta.ejb.EJBLocalHome_
*  _jakarta.transaction.UserTransaction_
* a _javax.naming.Context_ object for the
_java:comp/env_ context

a reference to an Enterprise Bean local or remote business interface or no-interface view

Web containers may support objects of other
types as well. Web containers must throw a
_java.lang.IllegalArgumentException_ if an object that is not one of the
above types, or another type supported by the container, is passed to
the _setAttribute_ or _putValue_ methods of an _HttpSession_ object
corresponding to a Jakarta EE distributable session. This exception
indicates to the programmer that the web container does not support
moving the object between VMs. A web container that supports multi-VM
operation must ensure that, when a session is moved from one VM to
another, all objects of supported types are accurately recreated on the
target VM.

The Servlet specification defines access to
local enterprise beans as an optional feature. This specification
requires that all Jakarta EE products that include both a web container and
an Enterprise Beans container provide support for access to local enterprise beans
from the web container.

The Jakarta Servlet specification is available at
_https://jakarta.ee/specifications/servlet/_ .

=== Server Pages 4.0 Requirements

The Jakarta Server Pages specification depends on and builds
on the servlet framework. A Jakarta EE product must support the entire
Jakarta Server Pages specification.

The Jakarta Server Pages specification is available at
_https://jakarta.ee/specifications/pages/_ .

=== Expression Language  (EL) 6.0 Requirements

The Jakarta Expression Language specification was
formerly a part of the Jakarta Server Pages specification. It was split off
into its own specification so that it could be used independently of
Jakarta Server Pages. A Jakarta EE product must support the Expression
Language.

The Jakarta Expression Language specification is
available at _https://jakarta.ee/specifications/expression-language/_ .

=== Messaging 3.1 Requirements

A Jakarta Messaging provider must be
included in a Jakarta EE product that requires support for Jakarta Messaging.
The Jakarta Messaging implementation must provide support for both
Jakarta Messaging point-to-point and publish/subscribe messaging, and thus
must make those facilities available using the _ConnectionFactory_ and _Destination_ APIs.

The Jakarta Messaging specification defines several
interfaces intended for integration with an application server. A Jakarta
EE product need not provide objects that implement these interfaces, and
portable Jakarta EE applications must not use the following interfaces:

*  _jakarta.jms.ServerSession_
*  _jakarta.jms.ServerSessionPool_
*  _jakarta.jms.ConnectionConsumer_

all _jakarta.jms_ XA interfaces

The following methods may only be used by
application components executing in the application client container:

*  _jakarta.jms.MessageConsumer_ method
_getMessageListener_
*  _jakarta.jms.MessageConsumer_ method
_setMessageListener_
*  _jakarta.jms.JMSConsumer_ method
_getMessageListener_
*  _jakarta.jms.JMSConsumer_ method
_setMessageListener_
*  _jakarta.jms.Connection_ method
_setExceptionListener_
*  _jakarta.jms.Connection_ method _stop_
*  _jakarta.jms.Connection_ method
_setClientID_
*  _jakarta.jms.JMSContext_ method _stop_
*  _jakarta.jms.JMSContext_ method
_setClientID_
*  _jakarta.jms.JMSContext_ method
_setExceptionListener_
*  _jakarta.jms.JMSContext_ method
_createContext_
*  _jakarta.jms.Producer_ method _setAsync_
*  _jakarta.jms.MessageProducer_ method
_send(Message_ _message, CompletionListener_ _completionListener)_
*  _jakarta.jms.MessageProducer_ method
_send(Message_ _message,_ _int_ _deliveryMode,_ _int_ _priority,_ _long_
_timeToLive,_ _CompletionListener completionListener)_
*  _jakarta.jms.MessageProducer_ method
_send(Destination_ _destination, Message_ _message,_
_CompletionListener_ _completionListener)_
*  _jakarta.jms.MessageProducer_ method
_send(Destination_ _destination, Message_ _message,_ _int_
_deliveryMode,_ _int_ _priority,_ _long_ _timeToLive,
CompletionListener_ _completionListener)_

The following methods may only be used by
application components executing in the application client container.
Note, however, that these methods provide an expert facility not used by
ordinary applications. See the JMS specification for further detail.

_jakarta.jms.Session_ method _setMessageListener_

*  _jakarta.jms.Session_ method
_getMessageListener_
*  _jakarta.jms.Session_ method _run_
*  _jakarta.jms.Connection_ method
_createConnectionConsumer_
*  _jakarta.jms.Connection_ method
_createSharedConnectionConsumer_
*  _jakarta.jms.Connection_ method
_createDurableConnectionConsumer_

_jakarta.jms.Connection_ method _createSharedDurableConnectionConsumer_

A Jakarta EE container may throw a
_JMSException_ (if allowed by the method) or a _JMSRuntimeException_ (if
throwing a _JMSException_ is not allowed by the method) if the
application component violates any of the above restrictions.

Application components in the web and enterprise bean
containers must not attempt to create more than one active (not closed)
_Session_ object per connection. An attempt to use the _Connection_
object’s _createSession_ method when an active _Session_ object exists
for that connection should be prohibited by the container. The container
should throw a _JMSException_ if the application component violates this
restriction. An attempt to use the _JMSContext_ object’s _createContext_
method should be prohibited by the container. The container should throw
a _JMSRuntimeException_ , since the first _JMSContext_ already contains
a connection and session and this method would create a second session
on the same connection. Application client containers must support the
creation of multiple sessions for each connection.

The Jakarta Messaging specification defines further
restrictions on the use of Jakarta Messaging in the Enterprise Beans and web containers. In
general, the behavior of a Jakarta Messaging provider should be the same in both the
enterprise beans container and the web container.

The Jakarta Messaging specification is available at
_https://jakarta.ee/specifications/messaging/_ .

=== Transaction 2.0 Requirements

Jakarta Transaction defines the _UserTransaction_ interface
that is used by applications to start, and commit or abort transactions.
Application components get a _UserTransaction_ object through a JNDI
lookup using the name _java:comp/UserTransaction_ or by requesting
injection of a _UserTransaction_ object.

Jakarta Transaction also defines the
_TransactionSynchronizationRegistry_ interface that can be used by
system level components such as persistence managers to interact with
the transaction manager. These components get a
_TransactionSynchronizationRegistry_ object through a JNDI lookup using
the name _java:comp/TransactionSynchronizationRegistry_ or by requesting
injection of a _TransactionSynchronizationRegistry_ object.

A number of interfaces defined by Jakarta Transaction are used
by an application server to communicate with a transaction manager, and
for a transaction manager to interact with a resource manager. These
interfaces must be supported as described in the Connector
specification. In addition, support for other transaction facilities may
be provided transparently to the application by a Jakarta EE product.

The Jakarta Transaction specification is available at
_https://jakarta.ee/specifications/transactions/_ .

=== Activation 2.1 Requirements

Jakarta Activation defines a set of standard services to: determine the MIME
type of an arbitrary piece of data; encapsulate access to it; discover the operations
available on it; and instantiate the appropriate bean to perform the operation(s).
A Jakarta EE product must support Activation.

The Jakarta Activation specification is available at
_https://jakarta.ee/specifications/activation/_ .

=== Mail 2.1 Requirements

The Jakarta Mail API allows for access to email
messages contained in message stores, and for the creation and sending
of email messages using a message transport. Specific support is
included for Internet standard MIME messages. Access to message stores
and transports is through protocol providers supporting specific store
and transport protocols. The Jakarta Mail API specification does not require
any specific protocol providers, but the Jakarta EE platform
should include an IMAP message store provider, a POP3 message
store provider, and an SMTP message transport provider.

Configuration of the Jakarta Mail API is
typically done by setting properties in a _Properties_ object that is
used to create a _jakarta.mail.Session_ object using a static factory
method. To allow the Jakarta EE platform to configure and manage Jakarta Mail
API sessions, an application component that uses the Jakarta Mail API should
request a _Session_ object using JNDI, and should list its need for a
_Session_ object in its deployment descriptor using a _resource-ref_
element, or by using a _Resource_ annotation. A Jakarta Mail API _Session_
object should be considered a resource factory, as described in
<<a1120, Resource Manager Connection Factory References>>. This specification requires that the
Jakarta EE platform support _jakarta.mail.Session_ objects as resource
factories, as described in that section.

The Jakarta EE platform requires that a message
transport be provided that is capable of handling addresses of type
_jakarta.mail.internet.InternetAddress_ and messages of type
_jakarta.mail.internet.MimeMessage_ . The default message transport must
be properly configured to send such messages using the _send_ method of
the _jakarta.mail.Transport_ class. Any authentication needed by the
default transport must be handled without need for the application to
provide a _jakarta.mail.Authenticator_ or to explicitly connect to the
transport and supply authentication information.

This specification does not require that a Jakarta
EE product support any message store protocols.

Note that the Jakarta Mail API creates threads to
deliver notifications of _Store_ , _Folder_ , and _Transport_ events.
The use of these notification facilities may be limited by the
restrictions on the use of threads in various containers. In Enterprise Beans
containers, for instance, it is typically not possible to create
threads.

The Jakarta Mail API uses the Jakarta Activation
API to support various MIME data types. The Jakarta Mail API must
include _jakarta.activation.DataContentHandlers_ for the following MIME
data types, corresponding to the Java programming language type
indicated in <<a2675, Jakarta Mail API MIME Data Type to Java Type Mappings>> .

[[a2675]]
[cols=2, options=header]
.Jakarta Mail API MIME Data Type to Java Type Mappings
|===
|Mime Type
|Java Type

|text/plain
|java.lang.String

|text/html_
|java.lang.String

|text/xml
|java.lang.String

|multipart/*
|jakarta.mail.internet.MimeMultipart

|message/rfc822
|jakarta.mail.internet.MimeMessage
|===

The Jakarta Mail API specification is available
at _https://jakarta.ee/specifications/mail/_ .

=== Connectors 2.1 Requirements

In full Jakarta EE products, all Jakarta Enterprise Beans containers
and all web containers must support the full set of Connector APIs. All
such containers must support Resource Adapters that use any of the
specified transaction capabilities. The Jakarta EE deployment tools must
support deployment of Resource Adapters, as defined in the Connector
specification, and must support the deployment of applications that use
Resource Adapters.

The Jakarta EE Connectors specification is available at
_https://jakarta.ee/specifications/connectors/_ .

=== RESTful Web Services 4.0 Requirements

Jakarta RESTful Web Services defines APIs for the development of
Web services built according to the Representational State Transfer
(REST) architectural style.

In a full Jakarta EE product, all Jakarta EE web
containers are required to support applications that use Jakarta RESTful Web Services
technology.

The specification describes the deployment of
services as a servlet. It must be possible to deploy Jakarta RESTful Web Services-based
applications using this deployment model with the _servlet-class_
element of the web.xml descriptor naming the application-supplied
extension of the Jakarta RESTful Web Services _Application_ abstract class.

The specification defines a set of optional
container-managed facilities and resources that are intended to be
available in a Jakarta EE container — all such features and resources must
be made available.

The Jakarta RESTful Web Services specification is available at
_https://jakarta.ee/specifications/restful-ws/_ .

=== WebSocket 2.2 (WebSocket) Requirements

The Jakarta WebSocket (WebSocket) is a
standard API for creating WebSocket applications. In a full Jakarta EE
product, all Jakarta EE web containers are required to support the
WebSocket API.

The Jakarta WebSocket specification can
be found at _https://jakarta.ee/specifications/websocket/_ .

=== JSON Processing 2.1 (JSON-P) Requirements

JSON (JavaScript Object Notation) is a
lightweight data-interchange format used by many web services. The
Jakarta JSON Processing (JSON-P) provides a convenient way to process
(parse, generate, transform, and query) JSON text.

In a full Jakarta EE product, all Jakarta EE
application client containers, web containers, and enterprise beans containers are
required to support the JSON-P API.

The Jakarta JSON Processing
specification can be found at _https://jakarta.ee/specifications/jsonp/_ .

[[a2713]]

=== JSON Binding 3.0 (JSON-B) Requirements

The Jakarta JSON Binding API for JSON Binding (JSON-B)
provides a convenient way to map between JSON text and Java objects.

In a full Jakarta EE product, all Jakarta EE
application client containers, web containers, and enterprise beans containers are
required to support the JSON-B API.

The Jakarta JSON Binding  specification
can be found at _https://jakarta.ee/specifications/jsonb/_.

=== Concurrency 3.1 (Concurrency Utilities) Requirements

Jakarta Concurrency Utilities for Jakarta EE is a
standard API for providing asynchronous capabilities to Jakarta EE
application components through the following types of objects: managed
executor service, managed scheduled executor service, managed thread
factory, and context service. In a full Jakarta EE product, all web
containers and enterprise beans containers are required to support the Concurrency
Utilities API. The Jakarta EE Product Provider must provide preconfigured
default managed executor service, managed scheduled executor service,
managed thread factory, and context service objects for use by the
application in the containers in which the Concurrency Utilities API is
required to be supported.

The Jakarta Concurrency
specification can be found at _https://jakarta.ee/specifications/concurrency/_ .

=== Batch 2.1 Specification Requirements

The Jakarta Batch provides a programming model for batch
applications and a runtime for scheduling and executing jobs.

In a full Jakarta EE product, all Jakarta EE web
containers and Jakarta Enterprise Beans containers are required to support the Batch API.

The Jakarta Batch specification can be found
at _https://jakarta.ee/specifications/batch/_ .

=== Authorization 3.0 Requirements

The Jakarta Authorization specification defines a contract
between a Jakarta EE application server and an authorization policy
provider. In a full Jakarta EE product, all Jakarta EE web containers and
enterprise bean containers are required to support this contract.

The Jakarta Authorization specification can be found at
_https://jakarta.ee/specifications/authorization/_ .

[[a2737]]
=== Authentication 3.1 Requirements

The Jakarta Authentication specification defines a service
provider interface (SPI) by which authentication providers implementing
message authentication mechanisms may be integrated in client or server
message processing containers or runtimes. Authentication providers
integrated through this interface operate on network messages provided
to them by their calling container. They transform outgoing messages
such that the source of the message may be authenticated by the
receiving container, and the recipient of the message may be
authenticated by the message sender. They authenticate incoming messages
and return to their calling container the identity established as a
result of the message authentication.

In a full Jakarta EE product, all Jakarta EE web
containers and enterprise bean containers are required to support the
baseline compatibility requirements as defined by the Jakarta Authentication
specification. In a full Jakarta EE product, all web containers must also
support the Servlet Container Profile as defined in the Jakarta Authentication
specification. In a Jakarta EE profile product that includes Servlet and
Jakarta Authentication, all web containers must also support the Servlet Container
Profile as defined in the Jakarta Authentication specification.
Support for the Jakarta Authentication SOAP Profile is not required.

The Jakarta Authentication specification can be found at
_https://jakarta.ee/specifications/authentication/_ .

[[a2741]]
=== Security 4.0 Requirements

Jakarta Security leverages Jakarta Authentication ,
but provides an easier to use SPI for authentication of users of web
applications and defines identity store APIs for authentication and
authorization.

In a full Jakarta EE product, all Jakarta EE web
containers and enterprise bean containers are required to support the
requirements defined by the Jakarta Security specification.

The Jakarta Security Specification can be
found at _https://jakarta.ee/specifications/security/_ .

=== Debugging Support for Other Languages Requirements 2.0

Jakarta Server Pages pages are usually translated into Java
language pages and then compiled to create class files. The Jakarta Debugging Support for Other Languages
specification describes information that can
be included in a class file to relate class file data to data in the
original source file. All Jakarta EE products are required to be able to
include such information in class files that are generated from
Jakarta Server Pages.

The Jakarta Debugging Support for Other Languages
specification can be found at _https://jakarta.ee/specifications/debugging/_ .

=== Standard Tag Library for Jakarta Server Pages 3.0 Requirements

Jakarta Standard Tag Library specification defines a standard tag library that
makes it easier to develop Jakarta Server Pages Pages. All Jakarta EE products are required
to provide a Jakarta Standard Tag Library for use by all Jakarta Server Pages.

The Jakarta Standard Tag Library for Jakarta Server Pages
specification can be found at _https://jakarta.ee/specifications/tags/_ .

=== Server Faces 4.1 Requirements

Jakarta Server Faces technology simplifies
building user interfaces for Jakarta applications. Developers of
various skill levels can quickly build web applications by: assembling
reusable UI components in a page; connecting these components to an
application data source; and wiring client-generated events to
server-side event handlers. In a full Jakarta EE product, all Jakarta EE web
containers are required to support applications that use the Jakarta Server
Faces technology.

The Jakarta Server Faces specification can be
found at _https://jakarta.ee/specifications/faces/_ .

=== Annotations 3.0 Requirements

The Jakarta Annotations specification defines
Java language annotations that are used by several other specifications,
including this specification. The specifications that use these
annotations fully define the requirements for these annotations. All other
containers must provide definitions for all of these annotations, and
must support the semantics of these annotations as described in the
corresponding specifications and summarized in the following table.

[cols=4, options=header]
.Annotations Support by Container
|===
|Annotation
|App Client
|Web
|Enterprise Beans

|Resource
|Y
|Y
|Y

|Resources
|Y
|Y
|Y

|PostConstruct
|Y
|Y
|Y

|PreDestroy
|Y
|Y
|Y

|Generated
|N
|N
|N

|RunAs
|N
|Y
|Y

|DeclareRoles
|N
|Y
|Y

|RolesAllowed
|N
|Y
|Y

|PermitAll
|N
|Y
|Y

|DenyAll
|N
|Y
|Y

|DataSourceDefinition
|Y
|Y
|Y

|DataSourceDefinitions
|Y
|Y
|Y

|Priority
|Y
|Y
|Y
|===
The Jakarta Annotations specification can be found at
_https://jakarta.ee/specifications/annotations/_ .

=== Persistence 3.2 Requirements

Jakarta Persistence is the standard API for the
management of persistence and object/relational mapping. The Jakarta
Persistence specification provides an object/relational mapping facility
for application developers using a Java domain model to manage a
relational database.

As mandated by the Jakarta Persistence
specification, in a Jakarta EE environment the classes of the persistence
unit should not be loaded by the application class loader or any of its
parent class loaders until after the entity manager factory for the
persistence unit has been created.

The Jakarta EE platform requires that if CDI is enabled, a _BeanManager_ instance
must be made available to Jakarta Persistence providers by the container.
The container is responsible for passing this _BeanManager_ instance
via the map that is passed as the second argument
to the _createContainerEntityManagerFactory(PersistenceUnitInfo, Map)_ method
of the _PersistenceProvider_ interface. The map key used must be
the standard property name _jakarta.persistence.bean.manager_.

The Jakarta EE platform also requires that if a Validation provider exists
in the container environment and the _validation-mode_ _NONE_ is not specified,
a _ValidatorFactory_ instance must be made available to Jakarta Persistence providers by the container.
The container is responsible for passing this _ValidatorFactory_ instance
via the map that is passed as the second argument
to the _createContainerEntityManagerFactory(PersistenceUnitInfo, Map)_ method
of the _PersistenceProvider_ interface. The map key used must be
the standard property name _jakarta.persistence.validation.factory_.

Additional requirements on Jakarta EE platform
containers are specified in the Jakarta Persistence specification
found at _https://jakarta.ee/specifications/persistence/_ .

=== Validation 3.1 Requirements

The Validation specification defines a
metadata model and API for JavaBean validation. The default metadata
source is annotations, with the ability to override and extend the
metadata through the use of XML validation descriptors.

The Jakarta EE platform requires that web
containers make an instance of _ValidatorFactory_ available to Jakarta Server Faces
implementations by storing it in a servlet context attribute named
_jakarta.faces.validator.beanValidator.ValidatorFactory._

The Jakarta EE platform also requires that an
instance of _ValidatorFactory_ be made available to Jakarta Persistence providers as a
property in the map that is passed as the second argument to the
_createContainerEntityManagerFactory(PersistenceUnitInfo, Map)_ method
of the _PersistenceProvider_ interface, under the name
_jakarta.persistence.validation.factory_ .

Additional requirements on Jakarta EE platform
containers are specified in the Validation specification, which can
be found at _https://jakarta.ee/specifications/bean-validation/_ .

=== Interceptors 2.2 Requirements

The Interceptors specification makes more
generally available the interceptor facility originally defined as part
of the Jakarta Enterprise Beans 4.0 specification.

The Interceptors specification can be found
at _https://jakarta.ee/specifications/interceptors/_ .

=== Contexts and Dependency Injection (CDI) 4.1 Requirements

The Contexts and Dependency Injection (CDI)
specification defines a set of contextual services, provided by Jakarta EE
containers, aimed at simplifying the creation of applications that use
both web tier and business tier technologies.

The CDI specification can be found at
_https://jakarta.ee/specifications/cdi/_ .

=== Dependency Injection for Java 2.0 Requirements

The Dependency Injection for Java (DI)
specification defines a standard set of annotations (and one interface)
for use on injectable classes.

In the Jakarta EE platform, support for
Dependency Injection is mediated by CDI. See
<<a2112, Support for Dependency Injection>> for more detail.

The DI specification can be found at
_https://jakarta.ee/specifications/dependency-injection/_ .

// generates a line between text and footnotes for pdf and html generation.
'''
